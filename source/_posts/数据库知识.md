---
title: 数据库知识
author: 不二
mathjax: true
date: 2021-01-05 16:50:20
tags: 数据库
img:
categories: 计算机基础
---

## ACID四原则

事务具有四个特性：原子性、一致性、隔离性和持久性。

- 原子性：事务是数据库的逻辑工作单位，不可分割，事务中包含的各操作要么都做，要么都不做。
- 一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。
- 隔离性：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
- 持久性：指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的，不能回滚。接下来的其它操作或故障不应该对其执行结果有任何影响。

## SQL

$DBMS种类 \begin{cases} 层次数据库(HDB):使用树形结构进行表示 \\ 关系数据库(RDB):由行列组成的二维表 \\ 面向对象数据库(OODB):把数据以及对数据操作集合起来以对象为单位进行管理 \\  XML数据库 \\ 键值存储系统(KVS):单纯保存使用的主键和值 \end{cases}$

$SQl种类 \begin{cases} DDL 数据定义语言 \\ DML 数据操纵语言 \\ DCL数据控制语言 \end{cases}$

SQL书写规则：

- 以分号结尾
- SQL不区分关键词的大小写，插入到表中的数据区分大小写
- 推荐关键字大写，表名的首字母大写，其余(列名等)小写
- 常数用单引号进行包裹
- 单词之间需要使用半角空格或者换行符进行分隔

### 数据库管理

创建数据库：`CREATE DATABASE <数据库名称>;`

创建表：`CREATE TABLE <表名> (<列名> <数据类型> <该类所需约束>,...,<该表的约束1>，<该表的约束2>);`

删除表：`DROP TABLE <表名>;`

表定义的更新：

- 添加列：`ALTER TABLE <表名> ADD COLUMN <列名> <列类型>;` Oracle和SQL Server中不用写COLUMN。，Oracle可以`ALTER TABLE <表名> ADD （ <列名>， <列名>，……）；`
- 删除列：`ALTER TABLE <表名> DROP COLUMN <列名>;`Oracle的特殊同上。

只能使用半角英文字母（开头）、数字、下划线作为数据库、表、列的名称。

同一数据库表不能重名，同一个表里列也不能重名。

$数据类型 \begin{cases} INTEGER:整数，非小数 \\ CHAR（在括号中指定存储的字符串的最大长度，不同的
RDBSM中可能长度单位是字符个数也可能是字节长度）\\ VARCHAR：同CHAR，但是不是定长，需要给定长度,不会用半角的空格进行补位(Oracle中使用VARCHAR2) \\ DATE:存储日期 \end{cases}$

对于`Mysql`来说，时间类型如下：

| 时间类型  | 占用空间 |      日期格式       |       最小值        |       最大值        |      零值表示       |
| :-------: | :------: | :-----------------: | :-----------------: | :-----------------: | :-----------------: |
| DATETIME  | 8 bytes  | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00 | 9999-12-31 23:59:59 | 0000-00-00 00:00:00 |
| TIMESTAMP | 4 bytes  | YYYY-MM-DD HH:MM:SS |   19700101080001    |  2038 年的某个时刻  |   00000000000000    |
|   DATE    | 4 bytes  |     YYYY-MM-DD      |     1000-01-01      |     9999-12-31      |     0000-00-00      |
|   TIME    | 3 bytes  |      HH:MM:SS       |     -838:59:59      |      838:59:59      |      00:00:00       |
|   YEAR    | 1 bytes  |        YYYY         |        1901         |        2155         |        0000         |

一般建表时候，创建时间用datetime，更新时间用timestamp。

数据表重命名：

- Oracle、PostgreSQL：`ALTER TABLE <表名> RENAME TO <新的表名>`
- DB2：`RENAME TABLE <表名> TO <新的表名>`
- SQL SERVER:`sp_rename '表名','新的表名'`
- Mysql:`RENAME TABLE <表名> TO <新的表名>`

### SELECT语句

基本语法：`SELECT <列名>,... FROM <表名>`。列名之间用逗号分割。

使用`*`进行select无法设定列的显示顺序，按照CREATE TABLE语句的定义顺序。

插入空行会导致执行错误。

使用`AS`为列设置别名，格式如下：`SELECT <列名> AS <别名>...`。**别名可以使用中文，但是要用双引号包裹。**

可以在`SELECT`语句中书写常量，如下所示。这些常量会显示在每条查询出的结果的前面。

```sql
SELECT '商品' AS string, 38 AS number, '2009-02-24' AS date,
product_id, product_name
FROM Product;
```

在`SELECT`语句中删除重复行时，使用关键词`DISTINCT`。DISTINCT 关键字只能用在第一个列名之前。`SELECT DISTINCT <列名> FROM <表名>`。`NULL`也会被合并。

`SELECT`语句通过`WHERE`子句指定查询条件。WHERE子句要紧跟在FROM子句之后。

单行注释`--`，**Mysql需要在`--`之后加上一个半角空格**。多行注释使用`/* */`。

**所有包含NULL的运算，其结果都是NULL。**即使除零也还是NULL。

FROM子句在SELECT中并不是必不可少，例如`SELECT (100 + 200) * 3 AS calculation;`Oracle不允许省略FROM。可以使用`DUAL`临时表。

不等于`<>`，`!=`不被标准SQL承认。

比较运算符可以对字符、数值和日期等几乎所有数据类型的列和值进行比较。

使用比较运算符时一定要注意不等号和等号的位置。

对字符串类型的数据进行大小比较时，规则是按照字典顺序。**以相同字符开头的单词比不同字符开头的单词更相近**。该规则对定长字符串和可变长字
符串都适用。

**不能对NULL使用比较运算符。**专门用来判断是否为 NULL 的 IS NULL或 IS NOT NULL  运算符。

NOT运算符用来否定某一条件，但是不能滥用。

多个查询条件进行组合时，需要使用AND运算符或者OR运算符。

AND 运算符优先于 OR 运算符，可以使用`()`，改变优先级。

使用 AND 运算符进行的逻辑运算称为逻辑积，使用 OR 运算符进行的逻辑运算称为逻辑和。

SQL中除了真值和假值以外，存在第三种，即不确定NULL。即三值逻辑。

### 聚合和排序

通常，聚合函数会对NULL以外的对象进行汇总。但是只有COUNT函数例外，使用COUNT（*）可以查出包含NULL在内的全部数据的行数。

| 函数  |             用处             |
| :---: | :--------------------------: |
| COUNT |    计算表中的记录数(行数)    |
|  SUM  | 计算表中数值列中数据的合计值 |
|  AVG  | 计算表中数值列中数据的平均值 |
|  MAX  | 计算表中数值列中数据的最大值 |
|  MIN  | 计算表中数值列中数据的最小值 |

`*`是COUNT函数特有的参数，其它函数不能使用其作为参数。COUNT(*)返回包含NULL的数据行数，COUNT(列名)则返回不包含NULL的数据行数。

**使用聚合函数时，NULL的数据会被排除在外，不能简单的理解为等价于0。**

SUM和AVG函数只对数值类型的列使用，MAX和MIN函数适用于任何数据类型的列。

去掉重复值的聚合函数，格式形如`SELECT COUNT (DISTINCT product_type) FROM Product`。

DISTINCT关键字必须写在括号中。写在外面会优先执行聚合函数，然后才是DISTINCT。

使用GROUP BY子句进行汇总：

```sql
SELECT <列名1>,<列名2>,<列名3>,...FROM <表名> GROUP BY <列名1>,<列名2>,<列名3>,...；
```

在GROUP BY子句中指定的列称为聚合键或分组列。

GROUP BY子句必须写在FROM子句之后。如果有WHERE子句，需要卸载WHERE子句之后。

聚合键中包含NULL时，在结果中会以“不确定”行（空行）的形式表现出来。

使用 WHERE 子句进行汇总处理时，会先根据 WHERE 子句指定的条件进行过滤，然后再进行汇总处理。

**子句书写顺序：SELECT -> FROM -> WHERE -> GROUP BY -> HAVING -> OREDER BY**

**子句执行顺序：FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> OREDER BY**

与聚合函数和GROUP BY子句有关的常见错误：

- 在SELECT子句中书写了多余的列。使用聚合函数时，SELECT子句只能存在以下三种元素：**常数，聚合函数，GROUP BY子句中指定的列名(也就是聚合键)**，MYSQL支持在多列候补中只要有一列满足要求就可以，其他RDBMS都不支持。因为聚合键和另外的列名不一定是一对一关系。
- 在GROUP BY子句中写了列的别名。在MYSQL中不算错误，但是不标准，因为标准SQL的执行顺序的影响，GROUP BY 时还未执行SELECT，系统也就不知道列的别名。
- GROUP BY子句结果的显示是无序的。
- 只有在SELECT子句、HAVING子句和ORDER BY子句中能够使用COUNT等聚合函数。

使用COUNT函数等对表中数据进行汇总操作时，为其指定条件的不是WHERE子句，而是HAVING子句。

 HAVING子句要写在GROUP BY子句之后。

**WHERE子句用来指定数据行的条件， HAVING子句用来指定分组的条件。**

```sql
SELECT <列名1>, <列名2>, <列名3>, ……
FROM <表名>
GROUP BY <列名1>, <列名2>, <列名3>, ……
HAVING <分组结果对应的条件>
```

HAVING 子句中能够使用的 3 种要素:**常数、聚合函数、GROUP BY子句中指定的列名**。

在 WHERE 子句和 HAVING 子句中都可以使用的条件，最好写在 WHERE 子句中。WHERE在排序之前就删去了部分数据，且便于建立索引，执行速度也会更快。

若查询没有指定顺序，则返回的结果往往是随机的。

OREDER BY：

```sql
SELECT <列名1>, <列名2>, <列名3>, ……
FROM <表名>
ORDER BY <排序基准列1>, <排序基准列2>, ……
```

不论何种情况， ORDER BY 子句都需要写在 SELECT 语句的末尾。这是因为对数据行进行排序的操作必须在结果即将返回时执行。

OREDER BY默认是升序，也可以显式声明`ASC`，使用关键词`DESC`降序。

`OREDER BY`指定多个排序键时，优先使用左侧的键，相同情况下在参考右侧的键。

**排序键中包含NULL时，会在开头或末尾进行汇总。**

在ORDER BY子句中可以使用SELECT子句中定义的别名。但是GROUP BY不可以。**因为 SELECT 子句的执行顺序在 GROUP BY 子句之后， ORDER BY 子句之前**。

在ORDER BY子句中可以使用SELECT子句中未使用的列和聚合函数。

## 索引

通过索引可以大幅提升查询数据的速度。

### 索引类型

主键、唯一键以及普通键等。

### 索引的数据结构

生成索引，建立二叉查找树进行二分查找或建立B-Tree结构进行查找或建立B+-Tree结构进行查找（MYSQl）或建立Hash结构进行查找。