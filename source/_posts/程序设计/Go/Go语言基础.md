---
title: Go语言基础
author: 不二
img: >-
  https://cdn.jsdelivr.net/gh/weiyouwozuiku/weiyouwozuiku.github.io@src/source/_posts/PageImg/程序设计/Go语言基础.jpg
mathjax: true
date: 2022-10-30 23:46:18
tags: Go
categories: 程序设计
---

## 逃逸分析

Go编译器会根据变量是否被外部引用决定是否逃逸，而不能像Cpp那样使用`new`明确指定在堆上创建。其原则是：

- 如果变量在函数外部没有引用，则**优先放在栈上**-> 超过栈的存储能力就会创建在堆上
- 如果变量在函数外部存在引用，则**必定放在堆上**

Cpp中的程序堆栈其实是OS层面的概念，它通过Cpp语言的编译器和所在系统环境来共同决定。 在程序启动时，操作系统会自动维护一个启动程序消耗内存的地址空间，并自动将这个空间从逻辑上划分为堆内存空间和栈内存空间。这时，“栈”的概念是指程序运行时自动获得的一小块内存，而后续的函数调用所消耗的栈大小，会在编译期间由编译器决定，用于保存局部变量或者保存函数调用栈。如果在 Cpp中声明一个局部变量，则会执行逻辑上的压栈操作，在栈中记录局部变量。而当局部变量离开作用域之后，**所谓的自动释放本质上是该位置的内存在下一次函数调用压栈的过程中，可以被无条件的覆盖**；对于堆而言，每当程序通过系统调用向操作系统申请内存时，会将所需的空间从维护的堆内存地址空问中分配出去，而在归还时则会将归还的内存合并到所维护的地址空间中。

Go 程序也是运行在操作系统上的程序，自然同样拥有前面提及的堆和栈的概念。**但区别在于传统意义上的“栈”被 Go 语言的运行时全部消耗了，用于维护运行时各个组件之间的协调，例如调度器、垃圾回收、系统调用等**。而对于用户态的 Go 代码而言，它们所消耗的“堆和栈”，其实只是 **Go 运行时通过管理向操作系统申请的堆内存，构造的逻辑上的 “堆和栈”**，**它们的本质都是从操作系统申请而来的堆内存**。由于用户态 Go 程序的“栈空间”是由运行时管理堆内存得来，相较于只有 1MB 的 C/C++ 中的“栈” 而言，Go 程序拥有“几乎”无限的栈内存 (1GB)。更进一步，对于用户态 Go 代码消耗的栈，Go 语言运行时会为了防止内存碎片化，会在适当的时候对整个栈进行深拷贝，将其整个复制到另一块内存区域（当然，这个过程对用户态的代码是不可见的）也就是GC，这也是相较于传统意义上栈是一块固定分配好的内存所出现的另一处差异。也正是由于这个特点的存在，**指针的算术运算不再能奏效，因为在没有特殊说明的情况下，无法确定运算前后指针所指向的地址的内容是否己经被 Go 运行时移动。**

## Defer

**使用defer会有短暂延迟。对时间要求高的程序避免使用**。

Defer的入参支持函数参数和函数闭包。需要注意函数闭包是引用。

当是函数参数时，则是参数本身被压栈。如果是闭包或者引用，则值可能会发生变化。

return之后的defer函数不能被注册。

return关键字并不是一个原语操作，其中分为两步1）返回值=xxx 2）空的return。而有defer的场景会在其中多一步调用defer函数、

## Tips

- `go build -gcflags '-m -l'`：`-m`输出编译的优化细节，`-N`关闭编译器优化，`-l`禁用内联优化。
- `go tool compile -S`：反汇编
