---
title: 单元测试知识
author: 不二
mathjax: false
date: 2021-03-02 11:06:53
tags: 单元测试
img:
categories:
categories: 经验总结
---

## 定义

单元测试是指对软件中的最小可测试单元 进行检查和验证。通常而言，一个单元测试是用于判断每个特定条件（或场景）下某个特定函数的行为，单元测试是由**开发**写的。执行单元测试是为了证明编写的功能代码与我们期望的一致。

### 引申概念

针对每个单独的小方法，在于程序其他部分相隔离的情况下进行测试，输入参数，校验出参是否合乎预期。因此，不测数据库操作、不测网络连接、不测依赖调用。以上的场景全部mock掉。

## 测试方向

### 自顶向下

此种方式不推荐，其为接口->接口实现类->原子实现类->Dao层。

### 自底向上

自底向上就是先测试下一层的方法，再测较高一层的方法，较高一层的方法在调用下一层方法的时候，也是mock掉的。方向为Dao层->原子实现类->接口实现类。

具体实现：框架级代码->工具类代码->原子实现类代码->接口实现类代码

## 特点

### 测试更充分

单元测试是最底层的测试，是白盒测试，能够测试所有正流程分支和异常分支，是最容易发现BUG的阶段，也能够发现其他测试环节发现不了的BUG，是接口测试和ui自动化测试无法代替的，是不同层次的覆盖。

### BUG修复代价最少

单元测试的后继阶段（功能继承测试 UAT测试 上线后的阶段）发现BUG修复的周期很长，修复的代价也更大。

### 代码自REVIEW

写单元测试的过程，也是一次代码REVIEW的过程。单元测试能促进开发者进行代码审查与优化，并能提高代码可读性。同时还能发现如下一系列问题：返回码错误、分支不可达、冗余的参数和方法、对象转换错误、空指针异常、死循环、日至记录错误、判断逻辑不严密等，并能给出代码健壮性建议。

### 代码功能更具易用性

编写单元测试将使我们从调用者角度观察、思考，审查功能是否易于调用和可测试的，可降低软件中的耦合性。

### 回归测试

如果核心功能的代码，单元测试行覆盖率和分支覆盖率足够高，重构后跑一遍单元测试，相关功能都能测试到，就不必担心代码重构时，影响其他功能。

### 快速定位BUG

如果程序中有BUG,我们运行一次全部单元测试，找到不通过的测试，可以很快的定位对应的执行代码。修复代码后，运行对应的单元测试；如还不通过，继续修改，运行测试，直至测试通过。

## 白盒测试技术

其中有六种相关技术：语句覆盖->判定覆盖->条件覆盖->判断条件覆盖->组合覆盖->路径覆盖，其测试强度从弱到强，相应的单侧工作量也越来越大。

### 语句覆盖

程序中每条语句至少执行一次，这样可以很直观的从源代码得到测试用例，无须细分每条判定表达式。但是隐式逻辑分支无法测试。

### 判定覆盖

每次判定至少一次为真值，有一次为假值，即：程序中每个分支至少执行一次。每次判断的取真、取假至少执行一次。覆盖强度几乎增加一倍，测试用例简单。但是关注焦点是表达式逻辑值，可能会遗漏部分测试路径。

### 条件覆盖

设计足够多的测试用例，使得判定中的每个条件获得各种可能的结果，即每个条件至少一次为真值，有一次为假值。相对判定覆盖，增加了对符合判定情况的测试，增加了测试路径。需要足够多的测试用例，条件覆盖并不能保证判定覆盖。

### 判断条件覆盖

设计足够多的测试用例，使得判定中每个天骄爱你的所有可能结果至少出现一次，每个判定本身所有可能结果也至少出现一次。满足判定覆盖准则和田间覆盖准则，弥补了二者的不足。但未考虑条件的组合情况，容易漏、会忽略田间中取或（or）的情况。

### 组合覆盖

使得每个判定中条件结果的所有可能组合至少出现一次。多重条件覆盖准则满足判定覆盖、条件覆盖和判定/田间覆盖准则。线性的增加了测试用例的数量，也不能不着所有路径被测试。

### 路径覆盖

覆盖程序中所有可能的路径。可以对程序进行彻底的测试，比前面的五种的覆盖面都广。但是需要设计大量、复杂的测试用例，使得工作量呈指数级增长，特殊路径无法测试。

