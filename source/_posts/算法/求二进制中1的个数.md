---
title: 求二进制中1的个数
author: 不二
img: >-
  https://cdn.jsdelivr.net/gh/weiyouwozuiku/weiyouwozuiku.github.io@src/source/_posts/PageImg/算法/求二进制中1的个数.jpg
mathjax: true
date: 2021-12-27 16:12:07
tags:
categories: 算法
---

## 问题描述

任意给定一个32位无符号整数n，求n的二进制表示中1的个数。

## 普通法

原理：移位+计数

```go
func BitCount(a uint32) (num uint32) {
	for num = 0; a != 0; a >>= 1 {
		fmt.Println(a, a&1)
		num += a & 1
	}
	return
}
```

缺点：这样会循环整个byte数组，运行较慢

## 快速法

原理：不断清除n的二进制表示中最右边的1，同时进行累加，直到n为0。

```go
func BitCount(a uint32) (num uint32) {
	for num = 0; a != 0; num++ {
		a &= a - 1
	}
	return
}
```

优点：其运算次数与输入n的大小无关，只与n中1的个数有关。

## 查表法

### 动态建表

由于表示在程序运行时动态创建的，所以速度上肯定会慢一些，把这个版本放在这里，有两个原因

1.  介绍填表的方法，因为这个方法的确很巧妙。
1.  类型转换，这里不能使用传统的强制转换，而是先取地址再转换成对应的指针类型。也是常用的类型转换方法。

```go
func BitCount(a uint32) (num uint8) {
	//建表
	BitSetTable := [256]byte{0}
	//init
	for i := 0; i < 256; i++ {
		BitSetTable[i] = byte(i&1) + BitSetTable[i/2]
	}
	//查表
	b := []byte{}
	b = append(b, byte(a>>24), byte(a>>16), byte(a>>8), byte(a))
	num = BitSetTable[b[0]] + BitSetTable[b[1]] + BitSetTable[b[2]] + BitSetTable[b[3]]
	return
}
```

先说一下填表的原理，根据奇偶性来分析，对于任意一个正整数n

1.如果它是偶数，那么n的二进制中1的个数与n/2中1的个数是相同的，比如4和2的二进制中都有一个1，6和3的二进制中都有两个1。为啥？因为n是由n/2左移一位而来，而移位并不会增加1的个数。

2.如果n是奇数，那么n的二进制中1的个数是n/2中1的个数+1，比如7的二进制中有三个1，7/2 = 3的二进制中有两个1。为啥？因为当n是奇数时，n相当于n/2左移一位再加1。

再说一下查表的原理

对于任意一个32位无符号整数，将其分割为4部分，每部分8bit，对于这四个部分分别求出1的个数，再累加起来即可。而8bit对应2^8 = 256种01组合方式，这也是为什么表的大小为256的原因。

注意类型转换的时候，先取到n的地址，然后转换为unsigned char*，这样一个unsigned int（4 bytes）对应四个unsigned char（1 bytes），分别取出来计算即可。举个例子吧，以87654321（十六进制）为例，先写成二进制形式-8bit一组，共四组，以不同颜色区分，这四组中1的个数分别为4，4，3，2，所以一共是13个1，如下面所示。

10000111 01100101 01000011 00100001 = 4 + 4 + 3 + 2 = 13

### 静态表-4bit

## 参考资料

1. 博客园，[算法-求二进制数中1的个数 ](https://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html)，2010
